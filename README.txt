	/// Формат строки:
	///     yyyy.MM.dd w HH:mm:ss.fff
	///     yyyy.MM.dd HH:mm:ss.fff
	///     HH:mm:ss.fff
	///     yyyy.MM.dd w HH:mm:ss
	///     yyyy.MM.dd HH:mm:ss
	///     HH:mm:ss
	/// Где yyyy - год (2000-2100)
	///     MM - месяц (1-12)
	///     dd - число месяца (1-31 или 32). 32 означает последнее число месяца
	///     w - день недели (0-6). 0 - воскресенье, 6 - суббота
	///     HH - часы (0-23)
	///     mm - минуты (0-59)
	///     ss - секунды (0-59)
	///     fff - миллисекунды (0-999). Если не указаны, то 0
	/// Каждую часть даты/времени можно задавать в виде списков и диапазонов.
	/// Например:
	///     1,2,3-5,10-20/3
	///     означает список 1,2,3,4,5,10,13,16,19
	/// Дробью задается шаг в списке.
	/// Звездочка означает любое возможное значение.
	/// Например (для часов):
	///     */4
	///     означает 0,4,8,12,16,20
	/// Вместо списка чисел месяца можно указать 32. Это означает последнее
	/// число любого месяца.
	/// Пример:
	///     *.9.*/2 1-5 10:00:00.000
	///     означает 10:00 во все дни с пн. по пт. по нечетным числам в сентябре
	///     *:00:00
	///     означает начало любого часа
	///     *.*.01 01:30:00
	///     означает 01:30 по первым числам каждого месяца
	/// </param>
		
	1. В классе Formatter хранится массив форматов. При запуске программы форматы (паттерны)
анализируются на совпадание, т.е. возможность декодирования. 
Каждый паттерн идентифицируется на основе символов разделителей ('.', ' ', ':')
Данный способ позволяет добавлять новые форматы или расширять существующие.
При задании расписания Shedule вызывается Formatter.DetectPattern. 
Полученный номер соответствует определенной кодовой последовательности элементов моментов.

Операции со строками сведены к операциям с char[] и списками с массивами char[].

	2. Каждое число момента времени времени хранится в виде левой границы, правой границы 
и шага в структуре Interval. Сами значения из интервала не генерируются.
При поиске значения внутри интервала реализуется проверка попадания числа путем 
нахождения остатка от деления на шаг.

	3. Для поиска ближайшего элемента среди наборов интервалов реализовано три метода
	3.1 Метод прямого поиска: среди неотсортированных списков ищет ближайший 
путем перебора
	3.2 Бинарный поиск - реализует предварительную сортировку списков по возрастанию и последующий бинарный поиск
	3.3 Самобалансируемое дерево интервалов. Реализует хранение списков в виде бинарного дерева интервалов.
Так как интервалы, вставляемые в дерево, не отсортированы оптимально, поэтому используется 
самабалансирующееся дерево интервалов АВЛ.
	
Для простоты, исключение одинаковых интервалов, пересечений не производится.

Выбор метода зависит от того, каким образом пользователь вводит данные и какая величина используется. 
По-умолчанию метод поиска - прямой.
Например, для величин с небольшими пределами (день недели, час) можно применять метод прямого поиска или бинарный.
Для большого числа списков, вводимых пользователем и широкого диапазона (миллисекунды, годы) 
можно применить бинарное дерево интервалов АВЛ.

	4. Непосредственный поиск ближайшего момента времени реализуется в классе MomentProcessing.
Сначала производится поиск ближайшего момента без учета дня недели.
Если найден и заданы дни недели - производится поиск по моментам, удовлетворяющим заданным дням недели.
При поиске момента, несовпадающего с заданным (Next) сравнивается заданный и полученный моменты.
Если они совпали мнимный входной момент увеличивается/уменьшается на 1 мс и производится повторный поиск.

Если момент времени не найден, выдается максимальное значение DateTime.

При поиске методы оперируют объектами класса Moment.
Каждый объект класса Moment содержит набор MomentItem (год, месяц, день, час, минута, секунда).

	5. Возможности улучшения:
- вместо char[] использовать ReadOnlySpan<char> (если необходимо часто, оперативно изменять расписание)
- везде вместо коллекций List использовать Span<Type>
- производить оценку максимума и минимума непосредственно при вставке в методе поиска. 
В таком случае методы NearestToMax(), NearestToMin() сводятся к получению Max, Min коллекции/дерева.


	
